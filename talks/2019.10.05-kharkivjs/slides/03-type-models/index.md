# Type Models

Основа в `Type Models` это генерация моделей из схемы, которую предоставляет вам сервер. Очень часто такой подход используется со Swagger'ом в REST API.

Получили описание серверного типа:

```graphql
type Image {
  url: URL!
  width: Int!
}
```

Сгенерировали модель со всеми полями:

```java
interface ImageModel {
  URL getUrl();
  int getWidth();
}
```

Такой подход достаточно хорошо скейлится в рамках одной команды.

#### Проблема 2.1: Алиасы

Допустим вам требуется запросить ссылки на изображения разного размера:

```graphql
fragment SquareImage on HasImage {
  smallPic: image(width: 40) {
    url
  }
  bigPic: image(width: 400) {
    url
  }
}
```

Сами модели, которые вы сгенерировали на базе серверных типов не будут содержать `alias`-полей. Вот есть поле `image` и геттер `getImage` для него. Так вот какое значение будет возвращаться `smallPic` или `bigPic`?

```java
Component render(HasImageModel model) {
  ImageModel smallPic = model.getImage();
  ...
}
```

Т.е. GraphQL-алиасы не получится использовать с `Type Models`. А терять фичу получения данных для "управляемых/настраевыемых" полей через аргументы не шибко хочется.

#### Проблема 2.2: Масштабирование

В Фейсбуке приблизительно

- ~30'000 типов
- ~200'000 полей

Представьте сколько классов и геттеров сгененрируется на базе серверной схемы! Что теперь весь сгененрированный код надо включать во все приложения и клиенты, которые могу использовать только сотую часть от всей схемы?! Это ужасно неоптимально. Чистить руками сгенерированный код, тоже не шибко интересная затея.

#### Вывод по Type Models

- ~~Опечатки (typos)~~
- ~~Отсутствие типовой безопасности (type safety)~~
- Недополучения данных (underfetch)
- Получение лишних данных (overfetch)

Генерация моделей из серверной схемы спасает от опечаток (typos) и отсутствия типовой безопасности (type safety).

Но проблема underfetch сохраняется: Если вы не запросили поле в запросе, то вы все равно сможете ошибочно вызвать это поле в вашей компоненте и нарваться на грех в рантайме (cannot read property of null, null pointer exception).

И проблема overfetch тоже никуда не девается: например вы упростили компоненту, перестав использовать какое-то поле и вдруг забыли удалить его в GraphQL-запросе, то вы будете тянуть данные ненужного поля на клиент. Ок, вы можете быть супер ответственным и удалить это поле и в запросе, но бац и приложение упало с проблемой `underfetch` – оказывается кто-то данные этого поля использует в другой части приложения. Т.е. если я удалил поле, то я должен пробежаться по всему приложению, чтобы убедиться в том, что его больше никто не использует.

Проблемы:

- Когда много команд
  - Все команды шарят между собой одну гигантскую библиотеку моделей типов
  - ИЛИ нет переиспользуемых компонентов/запросов между командами
  - ИЛИ разбивка на "собственные болота"
    - выбор верного болота или создавай свое
- Билды приложения могу ломаться, если другие команды удаляют поля из GraphQL-запросов
