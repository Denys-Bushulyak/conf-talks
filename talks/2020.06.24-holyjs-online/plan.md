# План доклада

- Зачем нужен GraphQL
  - Кто сейчас на GraphQL?
    - Github, Stripe, Paypal, Facebook, Shopify, Coursera
  - Что улучшается по сравнению с REST API
    - фильтрация полей
    - вложенные запросы с аргументами
    - вложенные аргументы (в ресте часто проблема микса фильтра, сортировки, проекции полей)
    - валидация
      - "Parameter 'createdDate' value is invalid" (2020-03-06 или 2020-03-06T14:47:49Z или 2020-03-06T14:47:49.000Z)
    - для сложных запросов не надо на клиенте писать модели
  - Что новые возможности дает GraphQL?
    - статический анализ
    - тулинг
      - визуализация схемы (Voyager)
      - валидация запросов и аргументов на стороне клиента
      - документация прям в редакторе запросов (Altair, Playground, Graphiql)
    - связи между Entity c возможностью указания дополнительных аргументов (HATEOAS тупой детский сад)
  - Когда не нужен GraphQL?
    - Когда работа с файлами (download/upload)
    - Когда простые запросы от клиентов
    - Когда мало Entity
- Методология (cтруктура GraphQL-прокси со средним временем на реализацию)
  - Практическая методология – это алгоритм, набор приёмов и способов того, как достичь желаемой практической цели.
  - M1) Создание `vendor` (обертка к REST API)
  - M2) Описание общих GraphQL-типов `schema/types`
  - M3) Описание Entity `schema/entities`
  - M4) Описание точек входа в граф `schema/query`, `schema/mutation`
  - M5) Расширение Entity прямыми связями по id
  - M6) Создание DataLoaders (N+1) `schema/dataLoaders`
  - M7) Создание Резолверов `schema/relations`
  - M8) Прикручивание QueryCost (DDOS)
- M1) Пишем vendor клиента
  - модели пишут либо на клиенте, либо на сервере
  - axios + debug
  - создаем все endpoints с примитивной типизацией
  - настраиваем проекцию полей `fields`
  - Микросервисная боль: Несколько сервисов необходимо вызывать, чтобы создать пользовательский аккаунт, назначить права, создать саб-аккаунт. Печально если ваши клиенты занимаются таким колхозом.
- M2) Описание общих GraphQL-типов `schema/types`
  - Что такое `graphql-compose`?
    - Это type registry, с возможность редактирования и клонирования типов для написания генераторов GraphQL-схем.
  - Скаляры
  - Enum
  - Output и Input
- M3) Описание Entity `schema/entities`
  - Это бизнес сущность с ID
  - Увидел DataExport со схемой. Сперва подумал, что зря все схемы руками состовлял. Можно было сгенерить GraphQL-схему из этих файлов. Но по доке увидел что не все Ентити заведены и всего 4 базовых типа. Получилась бы кака схема, без привязки к эндпоинтам, без нормальных связей, без QueryCost.
  - `graphql-compose-json`
  - ручное описание типов (документация, связи)
  - Когда обарачивал Task по response Json, то упустил кучу специфичных полей и получил неполное описание типа (упустил CustomFields, recurrent, dependencies потерял документацию)
- M4) Описание точек входа в граф
  - Что такое `graphql-compose-modules`
    - directoryToAst()
    - astToSchema()
    - изменение AST дерева
  - Описываем входные точки
    - `schema/query`
    - `schema/mutation`
    - `schema/subscription` (должны реализовываться отдельным этапом)
  - По завершению этого этапа получаем RestQL (графкуэль без связей)
- M5) Расширение Entity прямыми связями
  - Добавляем новые поля, которые возвращают связные Entity
- M6) Создание DataLoaders (N+1) `schema/dataLoaders`
  - Проблема N+1 <https://github.com/nodkz/conf-talks/blob/master/articles/graphql/dataloader/N+1.md>
  - Даталоадеры позволяют решить проблему N+1 и сократить кол-во HTTP запросов к REST API.
  - Пишем генераторы DataLoader'ов
    - 8 глобальных (записи возвращаются полностью, смело можно использовать глобально в рамках запроса)
    - 4 fieldNode-specific дата-лоадера (зависят от запрошенных полей в запросе)
  - Подключаем к TaskTC наши генераторы даталоадеров
- M7) Создание Резолверов `schema/relations`
  - Relations/Резолверы позволяют избавиться от копипасты. Позволяют расширять логику, например добавлять аргументы, оборачивать в даталоадеры и пр.
  - Добавляем прямые связи между Entity - `49 штук` (можно отключить через `DISABLE_RELATIONS`)
    - Например Task и ContactTC
  - Добавляем обратные связи между Entity – `25 штук` (можно отключить через `DISABLE_BACK_RELATIONS`)
    - Например ContactTC и tasksAuthored, tasksResponsible
  - Создал 14 резолверов (генераторов FieldConfig)
- M8) Прикручивание QueryCost (DDOS)  
  - QueryCost отрабатывает перед запуском выполнения запроса. Фактически мы пытаемся посчитать максимально возможно кол-во полей, которое вернет сервер, исходя из запроса и переданных переменных.
  - Выполняется после парсинга запроса, но до его выполнения
  - Создали плагин к аполло серверу `queryCostPlugin` и подключили его.
  - Добавляем `complexity` ко всем точкам входа в наш граф M4(полям Query). По желанию можно добавить к мутациям.
  - Добавлять `complexity` к релейшенам M7, которые возвращают списки
    - плохо, что не везде есть лимиты и сортировки (аттачменты, комменты) и мы запрашиваем тупо по ID
    - если нет аргументов limit или pageSize, то ставим `extensions: { complexity: ({ childComplexity }) => childComplexity * 10 }` (считаем что в списках в среднем возвращается 10 элементов)
- Дальнейшие улучшения для `wrike-graphql`
  - Тесты
    - тесты для vendor
    - тесты для GraphQL entry points
    - тесты для relations
  - Решение проблем REST API и Data Domain
    - Пагинация
      - ее много где тупо нет
      - есть `limit`, но нет `offset`
      - особенно печально, что поиск Folders нельзя итерировать. И чер его знает сколько там може вернуться записей, поэтому тяжело спрогнозировать сложность запроса.
    - Курсорная пагинация (вынести в отдельные точки входа и резолверы)
      - `nextPageToken` протухает через час-два (и опять запрашивать все данные сначала)
    - Сортировка есть далеко не везде
  - Вычисляемые поля, подключение внешних справочников, сторонних АПИ
  - Индетификация: указание токена клиента через HTTP-заголовки
  - ApolloFederation, GraphQLMesh для соединения с другими GraphQL-сервисами (например связать CustomFields с GitHub API)
  - Реализация Subscription (трансформция Web-hooks в WebSocket) для браузеров в основном.
