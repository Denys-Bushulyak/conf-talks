# Section 1: Intro -----------------

## О себе

## GraphQL это

- Язык запросов для вашего API (что просите, ровно то и получаете)
- Интроспекция АПИ из коробки (документация)
- Ваше API статически типизированное
- В одном запросе можно получить несколько ресурсов

# Section 2: Архитектура GraphQL-клиентов ------------------------- 

## Какие клиенты существуют

- `Relay 4` – amazing performance (complexity)
- `ApolloClient 2.6`  – balance between features and complexity
- Lokka - simple for vanilla JS
- fetch - Fetch API
- graphql-request – 150 LoC wrapper for fetch
- graphql.js – simple for vanilla JS, support fragments
- graphql-hooks – simple for React
- urql – simple for React

https://github.com/nodkz/conf-talks/tree/master/articles/graphql/clients

Нам интересны только `Relay` и `ApolloClient`, т.к. у них есть нормализованный стор и поддержка фрагментов.

## Relay 4.0

Марк Цукерберг 30 апреля 2019 презентовал новую версию facebook.com, которая написана на Relay. Супер быстрая и оптимизированная до самых ушей.
https://user-images.githubusercontent.com/1946920/57100220-2c4ba400-6d40-11e9-983f-387d8409fc8f.png

Ну чтож, сейчас Relay получит второе дыхание. И не говорить про него в своем докладе это кащунство.

Кому интересно, вот ссылка на видео где немного рассказывают про фишки, которые дал Relay новому сайту фейсбука: Building the New facebook.com with React, GraphQL and Relay – https://developers.facebook.com/videos/2019/building-the-new-facebookcom-with-react-graphql-and-relay/


## Development side

- Генерирует тайп дефинишены
  - показать примеры сгенерированных файлов
- Делают runtime-представление AST query/mutation
  - показать что выдает gql``, напомнить про бабель плагин для трансформации
- Оптимизируют запросы (сливают одинаковые поля, либо персистентные запросы)
  - показать как можно к экспресу привешать миддлевару, которая заменит `operationName` на `query`

RelayCompiler, Apollo Codegen (показать команды запуска и ссылки на доки)

## Runtime side

- Нормализированный кэш/стор
  - сокращаения данных в сторе (избавляет от дубликатов в записях)
  - Это когда ваш сильновложенный ответ от графкуэля, автоматически пересобирается в плоский вид: ключ (уникальный id, обычно `base64(__typename + ':' + id)`) и значение (набор скалярных параметров и ссылок на другие записи по ключу). И в таком плоском виде ключ-значение записывается в стор/кэш. Т.е. в таком случае вам не важно сколько раз вам вернулись данные и насколько глубоко они были вложены в графкуэль запросе, они на клиете будут храниться максимально компактно и удобно.
- Можно подписаться на измененные данные в сторе (обновлять компоненты)
- Mutation с оптимистичными апдейтами
  - Когда вы сразу меняете данные на клиенте, пока запрос на изменение данных летит на сервер. И в случае ошибки, данные обратно откатываются к первоначальному виду.
- Garbadge Collector кэша/стора (ссылка на релей, ссылка на аполло)

## Архитектура Relay и Apollo

Найдите 5 отличий.

### Relay

- Environment
  - Network
    - relay-network-layer-modern
  - Store
    - RecordSource
      - [[dataID, record], ...]
    - Subscriptions
      - на selectionSet (Selectors), т.е. на уровне фрагментов
    - GarbadgeCollector
      - работает на уровне references по dataID

### Apollo

- ApolloClient (QueryManager)
  - ApolloLink
    - link middlewares
  - ApolloCache (apollo-cache-inmemory)
    - NormalizedCache
      - [[dataID, record], ...]
    - watches: Set<Cache.WatchOptions>
      - работает на уровне [пробегись по всем Query](https://github.com/apollographql/apollo-client/blob/a132d8cdd76779120b25481b60ce0882a70656de/packages/apollo-cache-inmemory/src/inMemoryCache.ts#L370) и посмотри не поменялись ли в них данные
    - GarbadgeCollector
      - работает на уровне Query

Представьте что мутацией отредактировали часть записи так, что 800 зависимых записей остались непривязанными. Аполло их оставит в кеше а релей удалит. Аполло работает над этим, вроде как заработает [в версии Appllo Client 3](https://github.com/apollographql/apollo-client/pull/4681)

Потянет ли Ben Newman рефакторинг подписок на фрагменты, большой вопрос. До этого этим занимались Jonas Helfer и Sashko Stubailo (но они уже не в Аполло).

## Код аполло и релея на инициализации клиета

- relay-runtime
- apollo-client

## Код на инициализацию контекста в React

- react-relay
- react-apollo

## Как выполняются запросы

Сперва нормализуем в кеш, потом из кеша в ваши компоненты. TODO: проверить как аполло отдает в первый раз данные из запроса.

## Основные компоненты обертки

Relay:
QueryRenderer
RefetchContainer (не беда)
PaginationContainer (уже грустнее т.к. Relay Connection Spec)
FragmentContainer (удар по производительности на больших таблицах)

ApolloClient:
Query
Mutation
...

## Сравнение с Redux

Создание стора – нет такой задачи в вашем спринте.
Нет редьюсеров.
Экшены это нашы запросы.
Коннект - это нашу компоненты обертки.

## Сравнение с REST

GraphQL на сервере (да и на клиенте тоже) берет и выкидывает все выработанные годами практики как делать кэш.

На самом деле нет. Как вы кешировали серию запросов к ресту? Грубо говоря как кешировали агрегацию какую-нибудь?

# Section 3: Фрагменты -------------------------

## Пример запроса

В GraphiQL пишется запрос. Из запроса выделяется фрагмент. А уже дальше на базе фрагмента пишется реакт компонента.

Показать что запрос можно сделать через vanilla JS без фреймворков. Через консоль, NetworkTab  и `fetch` метод.
`body: { operationName: '', query: '', variables: {} }`.

## Что такое GraphQL-типы в терминах фронтендера

Это компоненты (виджеты). Например графкуэльный тип `User` может быть представлен на фронтенде 3 компонентами (`UserProfile`, `UserAvatar`, `UserKarmaWithName`).

## Проработать

1) Обычный квери на релее и на аполло. Когда вы создаете новый экран вы начинаете с Query, QueryRenderer.

2) Выносим в фрагменты. Далее все ваши реакт компоненты должны быть обернуты в фрагменты. Они не дергают данные напрямую с сервера, они просто описывают необходимый для себя набор данных.

3) Делаем вложенные фрагменты.
![sgwilym img](./sgwilym.png)

4) Чем хороши фрагменты для разных команд (сбор запроса снизу вверх).

Требует дополнительных настроект, но это позволяет построить архитектуру изолированных компонентов, которая легко масштабируется под размер команды и сложность приложения.

С GraphQL-фрагментами каждая компонента декларирует свои потребности в данных.

Каждая компонента получает только то, что запросила (только Relay, зовется это дело Datamasking).

8) В релее работает masking (вы не видите своих данных)

3) Ahead-of-time Safety

# DEMO time

Привязываем статический анализ к компонентам
    Настраиваем apollo-codegen, relay-compiler для генерации дефинишенов
    Берем тайп дефинишены фрагментов и присандаливаем их к пропсам компонент

15) Показать как переименовываются фрагменты

4) Лайфдемо: ломаем сервер по заявкам трудящихся
    Стараемся быстро найти поломанные места в клиенте
    Радуемся тому, как нас контролируют машины


## Болячка RESTовиков

Ущербность написания запроса целиком наверху (ей богу болячка RESTовиков)    
Запрос должен быть составным и собираться снизу вверх
Накидали компонентов, собрали с них фрагменты и 80% запроса уже готово
Кто-то внизу зарефакторил компоненту чтобы отображать больше данных – вам наверху пофигу, все работает из коробки.

## RestQL курильщика, и GraphQL нормального человека

GraphQL должен быть “волосатым”
Смотрим схему github в https://apis.guru/graphql-voyager/
Если фронтендер захотел по-маленькому… запросить данные, схема должна это позволять